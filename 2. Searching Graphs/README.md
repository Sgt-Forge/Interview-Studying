# Searching
Searching algorithms is a great way to practice your coding skills and help you learn about algorithms.  There exists many different searching algorithms, and all algorithms have specific use cases that make them better than others in certain use cases.  

We'll start with some terminology and graph theory to refresh your memory about graphs.  The refresher will get you up to speed for an interview if you're familiar with the content, but you should use the references and your *GoogleFu* to get a rock solid understanding of graph theory and the algorithms.

# Graph Theory 101 and Terminology
- What is a graph?  
A **graph** is a collection of objects that have some relation or connection to one another.  Typically, the objects in a graph are known as **verticies** or **nodes**.  The number of verticies in a graph is commonly represented by `V`.  A vertex can, but doesn't have to be, connected to another vertex by an **edge**.  The number of edges in a graph is commonly represented by `E`.  A common example of a graph might look like:

![example_graph](../images/example_graph1.png)

Notice that the verticies are represented by circles and edges are represented by lines.  We say that two nodes are **neighbors** or **adjacent** to one another when they are connected by an edge.  The idea of adjacent nodes becomes important when we talk about representing the neighbor relationship in code.

The above image is an example of an **explicit graph**.  When we say explicit, it means that we have defined all verticies and edges in the graph.  We defined verticies `0` through `5`, and we defined all edges, such as the edge `(0,4)` that connects vertex `0` to vertex `4`.  Explicit graphs are good at representing well defined objects, like the cities on a map, or the areas and paths in a video game map.  

Another common type of graph in niche fields is an **implicit graph**.  An implicit graph generates verticies and edges algorithmically.  Thus, the implicit graph will be generated at runtime rather than having a well definied example like the graph in the image above.  At most, you only need a single vertex and no edges at a given time.  Implicit graphs contain functions to generate the edges for a vertex.  An exmaple of an implicit graph is `c(n) = n/2`, and you repeatedly apply `c` to the result until your result is less than 1. A more complex version an implicit graph is generated by the *Collatz Problem* where `c(n) = n/2` if `n` is even, or `c(n) = 3n + 1` if `n` is odd.  Choose a starting `n` and apply `c(n)` until you reach 1 (if you reach 1).[[2]](https://stackoverflow.com/questions/58870416/can-you-explain-implicit-graphsin-graph-theory-with-a-simple-example)[[3]](https://martin-thoma.com/the-collatz-sequence/)

Implicit graphs may use slightly different terminology that explicit graphs.  We may talk about implicit graphs in terms of **branching factor** and **depth**.  The branching factor is the number of subsequent verticies for each vertex.  A branch factor may be the same for all verticies, or it may be an average across all verticies.  Depth is the distance between the **root node** and any other node.  The root node is the starting node for a graph or a **tree**, and a tree is a special type of graph that applies a hierarchical structure to graphs. The following image provides an example for branching factor, depth, and trees.
![tree_example](../images/tree_example1.png)

The root node is node `0`.  Notice that each node, except the **leaf nodes** have two **child nodes**.  A leaf node represents the last node on a **branch**, where branch is the same concept as an edge.  A child node is the node that follows another node in the tree heirarchy.  Node `1` is a child node to node `0`, and node `1` is also a parent node to node `3`.  We say that the branching factor for the example tree is 2 because each node (excluding the leaf nodes) has 2 children.  The example tree has a max depth of 2, because you travel 2 nodes until you hit a leaf node.  You could also list all nodes at a specific depth.  Nodes of depth 1 include nodes `1` and `2`.

It is difficult to talk about the number of verticies `V` and the number of edges `E` in an implicit graph, so we may talk about runtime and space complexity in terms of branching factor `b` and depth `d`.  We might say the runtime of a search algorithm is O(`b^d`)

# Sparse vs. Dense Graphs
We like to talk about how **sparse** or **dense** a graph is because it will tell us what algorithms and data structures to use when working with the graph in code.  Sparse and dense are loosely defined terms across the field, but there is some agreement about what they mean.  Informally, a sparse graph contains few edges while a dense graph contrains close the maximum number of edges.  Some say:
- A graph `G(V, E)` is sparse if `|E| = O(|V|)`.  i.e. the number of edges is approximately the same to the number of verticies
- A graph `G(V, E)` is dense if `|E| = O(|V|^2)`. i.e. the number of edges is approximately the same to the number of verticies squared. [[4]](https://stackoverflow.com/questions/12599143/what-is-the-distinction-between-sparse-and-dense-graphs)[[5]](https://web.archive.org/web/20160604215638/http://www.brpreiss.com/books/opus4/html/page534.html)

Let's picture a graph where each node is connected to every other node:

![dense_graph1](../images/dense_graph1.png)

Every vertex is connected to every other vertexin the above example.  Thus you have 6\*5 edges.  We can say that a vertex is connected to itself implicitly, or we can add an explicit edge that connects a vertex to itself, resulting in 6\*6 or 6^2 edges.  6 verticies and 6^2 edges is `|E| = O(|V|^2)`.  That's a dense graph!

On the other hand, a sparse graph has significantly fewer edges than a dense graph.  A sparse graph may even contain verticies that are disconnected from all other nodes as seen below:

![sparse_graph1](../images/sparse_graph1.png)

Notice that nodes `3` and `6` are disconnected from all other nodes.  There is no reason they must be connected to the rest of the graph.  Also notice that the value for `|E|` is significantly less than `|V|^2`, in fact, `|E| < |V|`.[[4]](https://stackoverflow.com/questions/12599143/what-is-the-distinction-between-sparse-and-dense-graphs)[[5]](https://web.archive.org/web/20160604215638/http://www.brpreiss.com/books/opus4/html/page534.html)


The idea of sparse vs. dense graphs leads into the next topic.  How do we be represent the edges of a graph?

# Adjacency Lists vs. Adjacency Matricies
Two commonly accepted ways to store edges for a graph: an **adjacency list** and an **adjacency matrix**.  

An adjacency list is the list of connected verticies for any given vertex.  For the sparse graph in the previous section, the adjacency list for node `4` would be `[2, 5]`.  You can represent the list with whatever data strucutres your coding language supports (i.e. arrays, vectors, lists, etc.).  If you designed a data structure for your verticies, you might consider adding a list that stores the neighbor nodes (i.e. the edges for that vertex). 

An adjacency matrix is a matrix or 2D array that marks if two verticies are connected.  Typically a 1 represents that two nodes are connected.  The adjacency matrix for the sparse graph in the previous section might look like:
```
0, 1, 0, 0, 0, 0
1, 0, 0, 1, 0, 0
0, 0, 0, 0, 0, 0
0, 1, 0, 0, 1, 0
0, 0, 0, 1, 0, 0
0, 0, 0, 0, 0, 0
```

You check for an edge between two verticies by indexing the row and column with the two vertex IDs.  To check if vertecies `4` and `5` are connected you would index to either [3][4] or [4][3] in the matrix because we take the IDs and subtract by 1 to account for indexing from 0.  Index [3][4] has a value 1, so we know nodes `4` and `5` are neighbors.

## When to Use Adjacency List or Adjacency Matrix
Use an adjacency matrix when:
- You have a dense graph
- when you want O(1) fast lookup time for the existence of an edge between two nodes
- When memory does NOT matter

Don't use an adjacency matrix when:
- You have a sparse graph: you are wasting memory.
- You want to iterate over all neighbors quickly
- You want to add/delte verticies quickly
- You want to optimize space complexity

You use adjacency matricies has `|V|^2` indicies by definition.  Therefore you should use an adjacency matrix when you have a dense graph.  The matrix offers fast lookup time because it uses indicies.  The space complexity of an adjacency matrix is poor because it uses `O(|V|^2)` memory.  It is slow to iterate over neighbors with adjacency matricies because you iterate over non-existent edges (i.e. `0` values in the matrix). It is difficult to add / delete verticies because you must resize/rebuild the matrix.  

Use an adjacency list when:
- You have a sparse graph
- You want to iterate over all neighbors / adjacenct verticies
- You commonly delete verticies
- You want to optimize memory complexity

Don't use an adjacency list when:
- You have a dense graph
- You want to find the presence or absense of an edge

Adjacency lists are good with sparse graphs because the lists are small and don't waste space by storing non-existent edges like an adjacency matrix would.  For the same reason, adjacency lists offer faster iteration over the list of neighbors.  It is easier to add and remove verticies with adjacency lists because you don't have to resize a matrix.  Adjacency lists are typically less space efficient with dense graphs.  It is slower to check if two verticies are connected when using an adjacency list.

# Breadth First Search (BFS)
## Summary
- What is BFS?
- When to use / What it's good at
## Runtime Complexity
## Space Complexity
# Depth First Search (DFS)
## Summary
- What is DFS?
- When to use / What it's good at
## Runtime Complexity
## Space Complexity
# Greedy Best First Search (GBFS)
## Summary
- What is GBFS?
- When to use / What it's good at
## Runtime Complexity
## Space Complexity
# Iterative Deepening Search (IDS)
## Summary
- What is IDS?
- When to use / What it's good at
## Runtime Complexity
## Space Complexity
# Dijkstra's 
## Summary
- What is Dijkstra's?
- When to use / What it's good at
## Runtime Complexity
## Space Complexity
# A* (A-Star)
## Summary
- What is A*?
- When to use / What it's good at
## Runtime Complexity
## Space Complexity

# Flash Cards
- Sparse vs. Dense Graphs
- Adjacency Matrix vs. Adjacency List

- DFS Time complexity
- DFS Space complexity
- When to use DFS

- BFS Time complexity
- BFS Space complexity
- When to use BFS

- GBFS Time complexity
- GBFS Space complexity
- When to use Greedy Best First Search

- IDS Time complexity
- IDS Space complexity
- When to use IDS

- Dijkstra's Time complexity
- Dijkstra's Space complexity
- When to use Dijkstra's

- A* Time complexity
- A* Space complexity
- When to use A*

# Terminology
- Graph
- Vertex
- Node
- Edge
- neighbor
- adjacent
- explicit graph
- implicit graph
- undirected graph
- directed graph
- Branching Factor
- Depth
- sparse
- Dense
- Adjacency matrix
- adjacency list
- root node
- leaf node
- child node
- branch

# Topics Not Covered
- Connected Graphs vs. Disconnected graphs
- Directional graphs vs. undirected graphs

# References

- [1] [Implicit Graphs by Washington EDU](https://courses.cs.washington.edu/courses/cse373/16wi/slides/18-Implicit-Graphs.pdf)
- [2] [Collatz Implicit Graph on StackOverflow](https://stackoverflow.com/questions/58870416/can-you-explain-implicit-graphsin-graph-theory-with-a-simple-example)
- [3] [Collatz Problem by Martin Thoma](https://martin-thoma.com/the-collatz-sequence/)
- [4] [Sparse vs. Dense Graphs on Stack Overflow](https://stackoverflow.com/questions/12599143/what-is-the-distinction-between-sparse-and-dense-graphs)
- [5] [Sparse vs. Dense Graphs by Bruno P. Reiss](https://web.archive.org/web/20160604215638/http://www.brpreiss.com/books/opus4/html/page534.html)
- [6] [Sparse vs. Dense and Matrix vs. List on CS StackExchange](https://cs.stackexchange.com/questions/54575/a-graphs-density-and-sparsity)
- [7] [Adjacency List and Adjacency Matrix Comparison on Stack Overflow](https://stackoverflow.com/questions/2218322/what-is-better-adjacency-lists-or-adjacency-matrices-for-graph-problems-in-c)

# Other Great Resources You Should Study